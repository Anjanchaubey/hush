<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Voice Chat</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #ffffff;
        }
        
        #app-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 25px 45px rgba(0, 0, 0, 0.1);
        }
        
        .btn {
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            border: none;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #4f46e5, #7c3aed);
            box-shadow: 0 8px 25px rgba(79, 70, 229, 0.3);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(79, 70, 229, 0.4);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }
        
        .btn-danger {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            box-shadow: 0 8px 25px rgba(239, 68, 68, 0.3);
        }
        
        .btn-danger:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 35px rgba(239, 68, 68, 0.4);
        }
        
        .input-field {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            color: white;
            font-size: 1.5rem;
            font-weight: 700;
            text-align: center;
            letter-spacing: 0.5rem;
            transition: all 0.3s ease;
        }
        
        .input-field:focus {
            background: rgba(255, 255, 255, 0.15);
            border-color: #4f46e5;
            box-shadow: 0 0 20px rgba(79, 70, 229, 0.3);
            transform: scale(1.02);
        }
        
        .input-field::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        h1 {
            background: linear-gradient(45deg, #ffffff, #e0e7ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        #room-status {
            background: linear-gradient(45deg, #10b981, #059669);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        #room-controls {
            gap: 2rem;
        }
        
        #room-controls button {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        #room-controls button svg {
            width: 28px;
            height: 28px;
            transition: all 0.3s ease;
        }
        
        #room-controls button:hover svg {
            transform: scale(1.1);
        }
        
        #participants-count {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            padding: 0.75rem 1.5rem;
            display: inline-block;
            font-weight: 600;
        }
        
        #error-message {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 8px;
            padding: 0.5rem;
            backdrop-filter: blur(10px);
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">

    <div id="app-container" class="w-full max-w-md p-8 space-y-6 rounded-2xl fade-in">

        <!-- Join View: Shown initially to enter a room code -->
        <div id="join-view">
            <h1 class="text-3xl font-bold text-center text-white">Simple Voice Chat</h1>
            <p class="text-center text-gray-400 mt-2">Enter a 4-digit room code to start or join a call.</p>
            <div class="mt-8 space-y-4">
                <div>
                    <input type="text" id="room-id" class="input-field w-full max-w-xs px-4 py-4 rounded-xl" placeholder="1234" maxlength="4" />
                </div>
                <button id="join-btn" class="btn btn-primary w-full px-6 py-4 rounded-xl font-semibold text-white">Join Room</button>
            </div>
            <p id="error-message" class="text-red-400 text-center mt-4 h-5"></p>
        </div>

        <!-- Room View: Shown after joining a room -->
        <div id="room-view" class="hidden">
            <div class="text-center">
                <h2 id="room-status" class="text-xl font-semibold text-white"></h2>
                <p class="text-gray-400">You are now in the voice chat.</p>
            </div>
            
            <div id="room-controls" class="flex justify-center items-center space-x-4 mt-8">
                <!-- Mute/Unmute Button -->
                <button id="mute-btn" class="btn btn-secondary">
                    <svg id="mic-on-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2a3 3 0 0 1 3 3v6a3 3 0 0 1-6 0V5a3 3 0 0 1 3-3z"/>
                        <path d="M19 10v1a7 7 0 0 1-14 0v-1a1 1 0 0 1 2 0v1a5 5 0 0 0 10 0v-1a1 1 0 0 1 2 0z"/>
                        <path d="M12 18.5a1 1 0 0 1 1 1V22a1 1 0 0 1-2 0v-2.5a1 1 0 0 1 1-1z"/>
                    </svg>
                    <svg id="mic-off-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor" class="hidden">
                        <path d="M436.418,244.958v-26.706h-35.395v26.706c-0.021,20.719-4.369,40.396-12.217,58.212l26.432,26.44C428.735,304.384,436.403,275.558,436.418,244.958z"/>
                        <path d="M336.135,244.958V80.124C336.121,35.926,300.209,0.014,256.003,0c-44.184,0.014-80.11,35.926-80.124,80.124v10.119l160.068,160.076C336.063,248.544,336.135,246.769,336.135,244.958z"/>
                        <path d="M393.815,361.087c0.202-0.237,0.431-0.453,0.633-0.69l-25.117-25.125c-0.194,0.244-0.431,0.46-0.626,0.704l-46.311-46.318c0.18-0.259,0.396-0.489,0.568-0.755L175.88,141.843v1.301L84.608,51.873l-25.8,25.793L175.88,194.737v50.22c0.014,44.184,35.94,80.096,80.124,80.11c14.423-0.007,27.928-3.888,39.627-10.579l46.692,46.692c-24.169,18.01-53.914,28.776-86.319,28.776c-40.001,0-76.164-16.228-102.482-42.531c-26.303-26.318-42.531-62.466-42.531-102.468v-26.706H75.597v26.706c0.028,91.494,68.438,167.033,156.828,178.675V512h47.188v-88.367c32.929-4.348,62.998-17.672,87.886-37.277l59.901,59.901l25.793-25.793L393.815,361.087z"/>
                    </svg>
                </button>
                <!-- Hang Up Button -->
                <button id="hangup-btn" class="btn btn-danger">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
                        <path d="M23 12.5 20.5 15l-3-2V8.842C15.976 8.337 14.146 8 12 8c-2.145 0-3.976.337-5.5.842V13l-3 2L1 12.5c.665-.997 2.479-2.657 5.5-3.658C8.024 8.337 9.855 8 12 8c2.146 0 3.976.337 5.5.842 3.021 1 4.835 2.66 5.5 3.658z"/>
                        <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.5 8.842C15.976 8.337 14.146 8 12 8c-2.145 0-3.976.337-5.5.842m11 0c3.021 1 4.835 2.66 5.5 3.658L20.5 15l-3-2V8.842zm-11 0c-3.021 1-4.835 2.66-5.5 3.658L3.5 15l3-2V8.842z"/>
                    </svg>
                </button>
            </div>
             <div id="participants-count" class="text-center text-gray-400 mt-4">Participants: 1</div>
        </div>
        
        <!-- This div will hold the audio elements for remote peers -->
        <div id="remote-audio-container"></div>
    </div>
    

    <!-- Firebase SDKs -->
    <script type="module">
        // Import necessary functions from Firebase SDKs
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, addDoc, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        
        // --- CONFIGURATION ---


        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCYY2GQqS0tCXb7Oxw8AWXhpexq9e8VRUs",
            authDomain: "aspirehub-32863.firebaseapp.com",
            projectId: "aspirehub-32863",
            storageBucket: "aspirehub-32863.appspot.com",
            messagingSenderId: "686810111182",
            appId: "1:686810111182:web:4290b4b1b6e64934ec449f",
            measurementId: "G-KX41R0SSMY",
            databaseURL: "https://aspirehub-32863-default-rtdb.asia-southeast1.firebasedatabase.app"
        };
        
        const appId = 'webrtc-voice-chat';

        // --- FIREBASE INITIALIZATION ---
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // --- WebRTC CONFIGURATION ---
        // Using a public STUN server from Google to help peers discover each other's IP addresses,
        // which is necessary for NAT traversal.
        const servers = {
            iceServers: [
                {
                    urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'],
                },
            ],
            iceCandidatePoolSize: 10,
        };

        // --- GLOBAL STATE VARIABLES ---
        let localStream;      // Holds the user's local microphone audio stream.
        let isMuted = false;  // Tracks the mute state.
        let roomId;           // The ID of the room the user is in.
        let userId;           // The unique ID for the current user.
        let peerConnections = {}; // An object to store RTCPeerConnection instances for each peer.
        let unsubscribeUserListener; // A function to stop listening to Firestore changes.

        // --- UI ELEMENTS ---
        const joinView = document.getElementById('join-view');
        const roomView = document.getElementById('room-view');
        const joinBtn = document.getElementById('join-btn');
        const roomIdInput = document.getElementById('room-id');
        const muteBtn = document.getElementById('mute-btn');
        const hangupBtn = document.getElementById('hangup-btn');
        const roomStatus = document.getElementById('room-status');
        const errorMessage = document.getElementById('error-message');
        const micOnIcon = document.getElementById('mic-on-icon');
        const micOffIcon = document.getElementById('mic-off-icon');
        const participantsCountEl = document.getElementById('participants-count');


        // --- AUTHENTICATION ---
        // Generate a unique user ID if anonymous auth fails
        let authReady = false;
        
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                authReady = true;
            } else {
                try {
                    await signInAnonymously(auth);
                } catch (error) {
                    console.warn('Anonymous auth failed, using fallback ID:', error);
                    // Fallback: generate a unique ID
                    userId = 'user_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
                    authReady = true;
                }
            }
        });


        // --- EVENT LISTENERS ---

        // Join Button: Handles the logic for joining a room.
        joinBtn.onclick = async () => {
            roomId = roomIdInput.value.trim();
            if (!/^\d{4}$/.test(roomId)) {
                errorMessage.textContent = 'Please enter a valid 4-digit room code.';
                return;
            }
            errorMessage.textContent = '';
            
            // Wait for auth to be ready
            let attempts = 0;
            while (!authReady && attempts < 50) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }
            
            if (!userId) {
                errorMessage.textContent = 'Authentication failed. Please refresh and try again.';
                return;
            }
            
            try {
                // 1. Get user's microphone access
                localStream = await navigator.mediaDevices.getUserMedia({ video: false, audio: true });

                // 2. Join the signaling room in Firestore
                await joinRoom();

                // 3. Switch UI to the room view
                joinView.classList.add('hidden');
                roomView.classList.remove('hidden');
                roomStatus.textContent = `Connected to Room: ${roomId}`;
            } catch (error) {
                console.error("Error joining room:", error);
                errorMessage.textContent = "Could not access microphone or join room.";
            }
        };

        // Mute Button: Toggles the local audio stream on and off.
        muteBtn.onclick = () => {
            isMuted = !isMuted;
            localStream.getAudioTracks()[0].enabled = !isMuted;
            micOnIcon.classList.toggle('hidden', isMuted);
            micOffIcon.classList.toggle('hidden', !isMuted);
            muteBtn.classList.toggle('bg-blue-600', isMuted);
            muteBtn.classList.toggle('bg-gray-600', !isMuted);

        };

        // Hang Up Button: Disconnects from the call and returns to the join screen.
        hangupBtn.onclick = async () => {
            await hangUp();
            roomView.classList.add('hidden');
            joinView.classList.remove('hidden');
            roomIdInput.value = '';
        };
        
        // Cleanup on page close
        window.addEventListener('beforeunload', hangUp);

        // --- CORE WEBRTC & FIRESTORE LOGIC ---

        /**
         * Joins the room, sets up listeners for other participants,
         * and announces presence.
         */
        async function joinRoom() {
            const roomRef = collection(db, `artifacts/${appId}/public/data/rooms/${roomId}/users`);
            const userDocRef = doc(roomRef, userId);

            // Add self to the room
            await setDoc(userDocRef, { joined: new Date() });

            // Listen for other users in the room
            unsubscribeUserListener = onSnapshot(roomRef, async (snapshot) => {
                const remoteUserIds = snapshot.docs
                    .map(doc => doc.id)
                    .filter(id => id !== userId); // Exclude self
                
                updateParticipantsCount(remoteUserIds.length + 1);

                // For each remote user, create a peer connection if one doesn't exist.
                for (const remoteUserId of remoteUserIds) {
                    if (!peerConnections[remoteUserId]) {
                        await createPeerConnection(remoteUserId, true); // This user is the offerer
                    }
                }
                
                 // Clean up connections for users who have left
                for (const existingPeerId in peerConnections) {
                    if (!remoteUserIds.includes(existingPeerId)) {
                        peerConnections[existingPeerId].close();
                        delete peerConnections[existingPeerId];
                        const remoteAudio = document.getElementById(`audio-${existingPeerId}`);
                        if(remoteAudio) remoteAudio.remove();
                    }
                }
            });

            // Listen for offers/answers/candidates on my own user document
            onSnapshot(userDocRef, (doc) => {
                const data = doc.data();
                if (data) {
                    // When receiving an offer from a peer
                    if (data.offer && !peerConnections[data.offer.from]) {
                        handleOffer(data.offer);
                    }
                    // When receiving an answer from a peer
                    if (data.answer) {
                        handleAnswer(data.answer);
                    }
                }
            });

            // Listen for ICE candidates from peers
             onSnapshot(collection(userDocRef, 'candidates'), (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === "added") {
                        const candidateData = change.doc.data();
                        const peerId = candidateData.from;
                        if (peerConnections[peerId] && peerConnections[peerId].remoteDescription) {
                            await peerConnections[peerId].addIceCandidate(new RTCIceCandidate(candidateData.candidate));
                        }
                    }
                });
            });
        }

        /**
         * Creates and configures an RTCPeerConnection for a given peer.
         * @param {string} peerId The UID of the remote peer.
         * @param {boolean} isOfferer True if this client is initiating the connection.
         */
        async function createPeerConnection(peerId, isOfferer) {
            console.log(`Creating peer connection to ${peerId}, isOfferer: ${isOfferer}`);
            peerConnections[peerId] = new RTCPeerConnection(servers);

            // Add local audio tracks to the connection to be sent to the peer.
            localStream.getTracks().forEach(track => {
                peerConnections[peerId].addTrack(track, localStream);
            });

            // When the remote peer adds their audio stream, this event fires.
            peerConnections[peerId].ontrack = event => {
                const remoteAudio = document.createElement('audio');
                remoteAudio.id = `audio-${peerId}`;
                remoteAudio.srcObject = event.streams[0];
                remoteAudio.autoplay = true;
                remoteAudio.playsInline = true;
                document.getElementById('remote-audio-container').appendChild(remoteAudio);
            };

            // When an ICE candidate is generated, send it to the peer via Firestore.
            peerConnections[peerId].onicecandidate = event => {
                if (event.candidate) {
                    const peerUserDocRef = doc(db, `artifacts/${appId}/public/data/rooms/${roomId}/users/${peerId}`);
                    const candidateCollection = collection(peerUserDocRef, 'candidates');
                    addDoc(candidateCollection, {
                        from: userId,
                        candidate: event.candidate.toJSON()
                    });
                }
            };
            
            // If this client is the one initiating, create and send an offer.
            if (isOfferer) {
                const offer = await peerConnections[peerId].createOffer();
                await peerConnections[peerId].setLocalDescription(offer);
                
                const peerUserDocRef = doc(db, `artifacts/${appId}/public/data/rooms/${roomId}/users/${peerId}`);
                await setDoc(peerUserDocRef, {
                    offer: {
                        from: userId,
                        sdp: offer.sdp,
                        type: offer.type
                    }
                }, { merge: true });
            }
        }
        
        /**
         * Handles an incoming offer from a peer.
         * @param {object} offer The offer object containing sdp, type, and from (peerId).
         */
        async function handleOffer(offer) {
            const peerId = offer.from;
            console.log(`Received offer from ${peerId}`);
            if (!peerConnections[peerId]) {
                 await createPeerConnection(peerId, false); // Not the offerer
            }
            
            const pc = peerConnections[peerId];
            await pc.setRemoteDescription(new RTCSessionDescription({ type: offer.type, sdp: offer.sdp }));
            
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);

            const peerUserDocRef = doc(db, `artifacts/${appId}/public/data/rooms/${roomId}/users/${peerId}`);
            await updateDoc(peerUserDocRef, {
                answer: {
                    from: userId,
                    sdp: answer.sdp,
                    type: answer.type
                }
            });
        }

        /**
         * Handles an incoming answer from a peer.
         * @param {object} answer The answer object containing sdp, type, and from (peerId).
         */
        async function handleAnswer(answer) {
            const peerId = answer.from;
             console.log(`Received answer from ${peerId}`);
            const pc = peerConnections[peerId];
            if (pc && !pc.currentRemoteDescription) {
                 const sessionDescription = new RTCSessionDescription(answer);
                 await pc.setRemoteDescription(sessionDescription);
            }
        }
        
        /**
         * Updates the participant count display.
         */
        function updateParticipantsCount(count) {
             participantsCountEl.textContent = `Participants: ${count}`;
        }

        /**
         * Cleans up all connections and Firestore data.
         */
        async function hangUp() {
            // Stop local media tracks
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            // Close all peer connections
            for (const peerId in peerConnections) {
                peerConnections[peerId].close();
            }
            peerConnections = {};
            
            // Remove audio elements
             document.getElementById('remote-audio-container').innerHTML = '';


            // Clean up Firestore data
            if (roomId && userId) {
                 const roomRef = collection(db, `artifacts/${appId}/public/data/rooms/${roomId}/users`);
                 const userDocRef = doc(roomRef, userId);

                // Stop listening for users
                if (unsubscribeUserListener) {
                    unsubscribeUserListener();
                }

                // Delete all candidates in the subcollection
                const candidatesCollectionRef = collection(userDocRef, 'candidates');
                const candidatesSnapshot = await getDocs(candidatesCollectionRef);
                const batch = writeBatch(db);
                candidatesSnapshot.docs.forEach((doc) => {
                    batch.delete(doc.ref);
                });
                await batch.commit();

                // Delete the user document
                await deleteDoc(userDocRef);
            }
            
            updateParticipantsCount(1);
            roomId = null;
        }

    </script>
</body>
</html>
